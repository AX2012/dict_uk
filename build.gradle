import java.text.Collator

apply plugin: 'java'
apply plugin: 'groovy'
apply plugin: 'eclipse'

compileJava.options.encoding = 'UTF-8'

version=new File("${projectDir}/VERSION").text.trim()
group = 'org.dict_uk'

String langCode="uk"

String affixDir="data/affix"
String dataDir="data/dict"

String outputDir="out"
String prevDir="../../out/prev"


repositories {
    mavenCentral()
}

//configurations {
//    groovyScript
//}

dependencies {
    implementation group: 'org.codehaus.groovy', name: 'groovy-all', version: '3.0.1'
    implementation group: 'org.codehaus.groovy', name: 'groovy-cli-picocli', version: '3.0.1'
    implementation 'info.picocli:picocli:4.0.4'

    implementation group: 'org.codehaus.gpars', name: 'gpars', version: '1.2.1'
    implementation group: 'commons-cli', name: 'commons-cli', version: '1.4'
    implementation group: 'ch.qos.logback', name: 'logback-classic', version: '1.2.3'
//    testCompile group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.3.2'

	testImplementation 'org.junit.jupiter:junit-jupiter-api:5.5.1'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.5.1'

//    groovyScript localGroovy()
}

//compileGroovy {
//    exclude '**/tools/other/*.groovy'
//}

eclipse {
  classpath {
    defaultOutputDir = file('build')
  }
}


//
// Auxilliary targets
//

task reverseVerbs (type: JavaExec, dependsOn: classes) {
    def inputFile = "$affixDir/v.aff"
    inputs.file inputFile
    outputs.file "$affixDir/vr.aff"

    classpath = sourceSets.main.runtimeClasspath
    main = "org.dict_uk.expand.VerbReverse"
    args file(inputFile), file(outputs.files[0])

//    standardInput = file(inputFile).newInputStream()
//    standardOutput = file(outputs.files[0]).newOutputStream()
}

task reverseAdvp (type: JavaExec, dependsOn: classes) {
    def inputFile = "$affixDir/v_advp.aff"
    inputs.file inputFile
    outputs.file "$affixDir/vr_advp.aff"

    classpath = sourceSets.main.runtimeClasspath
    main = "org.dict_uk.expand.VerbReverse"

    args file(inputFile), file(outputs.files[0])
}

task autoGen (dependsOn: classes) {
    def inputFile1 = "$dataDir/base.lst"
    def inputFile2 = "$dataDir/base-compound.lst"

    inputs.file inputFile1
    inputs.file inputFile2
    outputs.file "$dataDir/base-autogen.lst"

    doLast {
        String[] lines = file(inputFile1).readLines("UTF-8")
            .findAll { line -> line.contains(":ua_1992") }

        def outReplaceLines = []

        String[] outLines1 = lines
            .findAll { line -> line =~ /проек[тц]|хіміо/ }
            .collect { line ->
                assert ! line.contains('#>')

                String newLine = line.replaceFirst(/проек([тц])/, 'проєк$1').replace('хіміо', 'хіміє')
                newLine = newLine.replace('ua_1992', 'ua_2019')

                String newLemma = line.replaceFirst(/(.*?) .*/, '$1').replace('проек', 'проєк')
                def newReplLine = line.padRight(64) + "#> $newLemma"
                outReplaceLines << newReplLine

                newLine
            }

        def pattern2 = ~ /(^|[а-яіїєґ']+-)(архі|архи|боді|гіпер|диско|екстра|камер|макро|максі|міді|мікро|міні|мульти|нано|полі|преміум|супер|топ|ультра|анти|контр|віце|екс|лейб|обер|штабс|унтер)-([^ ]+)(.*)/

        def lines2 = file(inputFile2).readLines("UTF-8")

        String[] outLines2 = (lines + lines2)
            .findAll { line -> pattern2.matcher(line).find() }
            .collect { line ->
                if( line.contains('#>') ) {
                    println "Skipping replace in: $line"
                    line = line.replaceFirst(/ *#>.*/, '')
                }

                String newLine = pattern2.matcher(line).replaceFirst('$1$2$3$4')
        // TODO: make generic
                newLine = newLine.replace('ua_1992', 'ua_2019')
                newLine = newLine.replace('камерю', 'камер\'ю')

                String newLemma = pattern2.matcher(line).replaceFirst('$1$2$3')
                def newReplLine = line.padRight(64) + "#> $newLemma"
                outReplaceLines << newReplLine

                newLine
            }

        outLines1 += outLines2


        lines = file(inputFile2).readLines("UTF-8")
//            .findAll { line -> line.contains(":ua_1992") }

        def pattern3 = ~ /(^|-)(арт|бліц|веб|етно|кібер|компакт|мас|медіа|поп|прес|флеш|фоль?к|шоу)-/

        String[] outLines3 = lines
            .findAll { line -> pattern3.matcher(line).find() }
            .collect { line ->
                if( line.contains('#>') ) {
                    println "Skipping replace in: $line"
                    line = line.replaceFirst(/ *#>.*/, '')
                }

                String newLine = pattern3.matcher(line).replaceFirst('$1$2')
                newLine = newLine.replace('ua_1992', 'ua_2019')
            }

        outLines1 += outLines3

        // allow both forms

        def pattern4 = ~ /(^|-)(інтернет|піар|секс|фан|фітнес)-/

        String[] outLines4 = lines
            .findAll { line -> pattern4.matcher(line).find() }
            .collect { line ->
                if( line.contains('#>') ) {
                    println "Skipping replace in: $line"
                    line = line.replaceFirst(/ *#>.*/, '')
                }

                String newLine = pattern4.matcher(line).replaceFirst('$1$2')
//                newLine = newLine.replace('ua_1992', 'ua_2019')

                String newLemma = pattern4.matcher(line).replaceFirst('$1$2')
                def newReplLine = newLemma.padRight(64) + "#> " + line.replaceFirst(/^([^ ]+).*/, '$1')
                outReplaceLines << newReplLine

                newLine
            }

        outLines1 += outLines4


        Collator collator = Collator.getInstance(new Locale("uk", "UA"));
        outputs.files.first().setText(outLines1.toSorted(collator).join("\n"), "UTF-8")

        new File('data/dict/base-auto-replace.txt').setText(outReplaceLines.toSorted(collator).join('\n'), "UTF-8")
    }
}

task reverseAffix (dependsOn: [reverseVerbs, reverseAdvp]) {
}


task sortDict(type: JavaExec) {
	classpath = sourceSets.main.runtimeClasspath
	main = "org.dict_uk.tools.Sort"

	workingDir = file("data/dict")
	
	def files = "alt.lst base-abbr.lst base.lst base-compound.lst colors.lst dot-abbr.lst"
	files += " geo-ukr-hydro.lst geo-other.lst"  //  geo-ukr-koatuu.lst
	files += " slang.lst twisters.lst ignored.lst names-anim.lst names-other.lst rare.lst"
	files += " names-composite.lst base-composite.lst subst.lst"

	args files.split()
}


task dups {
  doLast {
	def dictDir = file("data/dict")
	
	def files = dictDir.listFiles().findAll { it.name.endsWith('.lst') \
	    && ! (it.name in ['dot-abbr.lst', 'geo-ukr-hydro.lst', 'geo-ukr-koatuu.lst']) }
	
	def lines = files.collect {  it.text.split("\n")  }.flatten() \
	    .collect { it
	        .trim()
	        .replaceAll(/\s*#.*/, '')
	        .replaceAll(/\.[^< ]+/, '...')
	        .replaceAll(/:&adjp:(actv|pasv)(:(imperf|perf))+/, '') } \
	    .grep { it && ! it.startsWith("+cs") }

    lines = lines.grep { ! it.startsWith('#') }

    def dups = lines.countBy{it}.grep{it.value > 1 }.collect{it.key}

    java.text.Collator coll = java.text.Collator.getInstance(new Locale("uk", "UA"));
    coll.setStrength(java.text.Collator.IDENTICAL)
    coll.setDecomposition(java.text.Collator.NO_DECOMPOSITION)


    println dups.toSorted(coll).join("\n")
    println "Found ${dups.size} dups"
  }
}

task checkReplacements {
  doLast {
	def dictDir = file("data/dict")
	
	def files = dictDir.listFiles().findAll { it.name.endsWith('.lst') }
	
	def replWords = files.collect { it.text.split("\n")  } \
	    .flatten() \
	    .findAll { it.contains(" #> ") }
	    .collect { it.split(" #> ")[1].trim().split(/[;, \|]+/) }
	    .flatten()
	    .collect { it.replaceAll(/[()]/, '').replaceFirst(/-таки$/, '') }
	    .findAll { it =~ /[а-яіїєґ]/ }
	    .unique().sort()

    def spellWords = new File("out/words_spell.txt").text.split("\n")
    
    println "Unique replacement words: ${replWords.size}"
    
    replWords.removeAll(spellWords)


    println "Unknown:\n" + replWords.join("\n")
    println "Total uknown: ${replWords.size}"
  }
}


task showExpandCommand {
  doLast {
    def opts = " --corp --indent --mfl --stats --wordlist --time"
    opts += " -aff data/affix"
    opts += " -dict data/dict"

    def cmd = "groovy -cp "
    cmd += sourceSets.main.output.classesDir
    cmd += ":" + sourceSets.main.output.resourcesDir
    cmd += ":" + configurations.runtime.asFileTree.files.join(':')
//    cmd += " org.dict_uk.expand.ExpandAll"
    cmd += " src/main/groovy/org/dict_uk/expand/ExpandAll.groovy"
    cmd += opts
    
    println cmd
  }
}

//
// Testing targets
//

def getAdjustedText(filename) {
       new File(filename).text.replace("\r\n", "\n")
}


task testExpand(type: JavaExec, dependsOn: [reverseAffix, autoGen, classes]) {
    classpath = sourceSets.main.runtimeClasspath
    main = "org.dict_uk.expand.ExpandAll"

    workingDir = file('test')

    def opts = "--corp --indent --mfl --stats --wordlist"
    args "--aff", "../data/affix"
    args "--dict", "dict"
    args opts.split()

//    jvmArgs "-XX:+FlightRecorder -XX:StartFlightRecording=disk=true,dumponexit=true,filename=recording.jfr".split()

    doLast {
        def file="dict_corp_lt.txt"
        def noTestOutputChange = getAdjustedText("$workingDir/$file") == getAdjustedText("$workingDir/prev/$file")
        assert noTestOutputChange

        file="dict_corp_vis.txt"
        def noTestVisOutputChange = getAdjustedText("$workingDir/$file") == getAdjustedText("$workingDir/prev/$file")
        assert noTestVisOutputChange

//        def noTestTagsOutputChange = getAdjustedText("$workingDir/tags.txt") == getAdjustedText("$workingDir/prev/tags.txt")
//        assert noTestTagsOutputChange
    }
}


//
// Main targets
//

task expandForCorp(type: JavaExec, dependsOn: [reverseAffix, autoGen/*, testExpand*/]) {
    classpath = sourceSets.main.runtimeClasspath
    main = "org.dict_uk.expand.ExpandAll"

    workingDir = file(outputDir)

    def opts = "--corp --indent --mfl --stats --wordlist --time"
    // opts += "--removeWithRegex verb.*:inf.*:coll"            // remove colloquial verb forms

    args "--aff", "../data/affix"
    args "--dict", "../data/dict"
    args opts.split()

    jvmArgs "-Xms4000m -Xmx4500m".split()
    // JDK8
//    jvmArgs "-XX:+UnlockCommercialFeatures -XX:+FlightRecorder -XX:FlightRecorderOptions=defaultrecording=true,dumponexit=true,dumponexitpath=dumponexit.jfr".split()
    // JDK11
//    jvmArgs "-XX:+FlightRecorder -XX:StartFlightRecording=disk=true,dumponexit=true,filename=recording.jfr".split()
//    jvmArgs "-agentlib:jdwp=transport=dt_socket,server=y,address=8000,suspend=n"
}

def get_diff_cmd(outputDir, file) {
    return "diff -u $outputDir/prev/$file $outputDir/$file > $outputDir/${file}.diff || echo 'File $file differs!'"
}


task diff(type: Exec) {
    def dictFile="dict_corp_lt.txt"

//    def cmd = get_diff_cmd(outputDir, dictFile)
//    cmd += "; " + get_diff_cmd(outputDir, 'words.txt')
//    cmd += "; " + get_diff_cmd(outputDir, 'words_spell.txt')
//    cmd += "; " + get_diff_cmd(outputDir, 'lemmas.txt')
//    cmd += "; " + get_diff_cmd(outputDir, 'tags.txt')

    dictFile="dict_corp_vis.txt"
    def cmd = get_diff_cmd(outputDir, dictFile)

    commandLine "sh", "-c", "${cmd}"
}

task expand(dependsOn: expandForCorp) {
}


task expandInteractive(type: JavaExec, dependsOn: reverseAffix) {
    classpath = sourceSets.main.runtimeClasspath
    main = "org.dict_uk.expand.Expand"

    workingDir = file(outputDir)
    standardInput = System.in

    def opts = "--corp -f"
    if( ! project.hasProperty('flat') ) {
        opts += " --indent"
    }
    args "--aff", "../data/affix"
    args "--dict", "-"
    args opts.split()
}



task runTool(type: JavaExec, dependsOn: compileGroovy) {
    classpath = sourceSets.main.output + configurations.runtimeClasspath
    main = "groovy.ui.GroovyMain"
    args "src/tools/groovy/" + (project.hasProperty('tool') ? project.tool : '')
    if( project.hasProperty('file') ) {
        println "Reading word list from: " + project.file
        args project.file
    }
}


//
// deploy LT dict
//

task deployLtDict(type: GradleBuild) {
    dir = 'distr/morfologik-ukrainian'
    tasks = ['deployLtDict']
}


// windows have non-unicode encoding set by default
String osName = System.getProperty("os.name").toLowerCase();
if ( osName.contains("windows")) {
    if( ! "UTF-8".equals(System.getProperty("file.encoding")) ) {
        println "On Windows to get unicode handled correctly you need to set environment variable before running expand:"
        println "\tbash:"
        println "\t\texport JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF-8"
        println "\tcmd:"
        println "\t\t(change Font to 'Lucida Console' in cmd window properties)"
        println "\t\tchcp 65001"
        println "\t\tset JAVA_TOOL_OPTIONS=-Dfile.encoding=UTF-8"
        println "\n\tNOTE: bash shell (e.g. git bash) is recommended: only in bash the output will handle all cyrillics and expandInteractive only supported in bash"

        // poor man's safety net (may work but still will not show all cyrillic characters)
        tasks.each { task ->
            if( task instanceof JavaExec ) {
                task.jvmArgs '-Dfile.encoding=UTF-8'
            }
        }
    }
}

task fatJar(type: Jar) {
    manifest {
        attributes 'Implementation-Title': 'dict_uk classes',
            'Implementation-Version': archiveVersion
    }
    archiveBaseName = project.name + '-all'
    from { configurations.compile.collect { it.isDirectory() ? it : zipTree(it) } }
    with jar
}
